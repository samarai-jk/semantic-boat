# STM32 project structure (CubeMX-friendly)

This project keeps all application logic outside of CubeMX-generated files. Only minimal calls live in `Core/Src/main.c` inside USER CODE regions.

## Folders
- Core/Inc, Core/Src: Generated by CubeMX. Do not modify outside USER CODE regions.
- App/: Application entry points and orchestration (your code). Add more modules as needed.
- Drivers/: HAL and CMSIS (generated).

A common layering you can follow as the project grows:
- App/            — startup, main loop, state machines (e.g., `app_init()`, `app_step()`).
- BSP/            — board/pin helpers (LEDs, relays, PWM, ADC routing).
- Services/       — reusable services (debounce, scheduler, PID, filters, I2C/SMBus helper).
### SMBus (I2C1) Slave Driver

The `SmBusDriver` exposes the device as an SMBus slave on I2C1 (PB6=SCL, PB7=SDA) address 0x02 with SMBALERT# on PB5.

Events:
- `EVT_SMBUS_DATA_RECEIVED` — payload is the bytes written by a master.
- `EVT_SMBUS_ALERT_ASSERTED` / `EVT_SMBUS_ALERT_RELEASED` (currently not published automatically; you can extend driver to emit when calling assert/release.)

Driver API highlights:
- `setResponse(buf,len)` queue bytes that will be sent when a master performs a read.
- `assertAlert()` / `releaseAlert()` drive SMBALERT# low/high for testing.
- `enableAlertBlink(true, period_ms)` to periodically toggle SMBALERT# so you can probe it on a scope without a master present.

Scope-only bring-up (no master yet):
1. Instantiate the driver via factory (add `DRV_SMBUS` to enabled driver list in your app init if not already).
2. Call `enableAlertBlink(true, 250)` somewhere after init to get a 2 Hz square wave on PB5 (active-low pulses).
3. Build & flash. Probe PB5 with oscilloscope: you should see periodic low pulses (line idles high due to external pull-up or internal). If not, verify pull-ups on SCL/SDA/SMBA lines (typically 4.7kΩ to 3V3).
4. (Optional) To view bus idle levels, trigger on falling edge of PB5. SCL/SDA remain high unless you manually force transactions.
5. To test TX path: call `setResponseU8(0xA5)`; then when you later attach an external master and read from address 0x02 you should see 0xA5.

Alert pulse test without blink:
```
SmBusDriver::instance()->pulseAlert(10); // drives low for ~10 ms then releases
```

Extending for automatic alert event publishing: inside `assertAlert()` and `releaseAlert()` call `EventBus::instance().publish(EVT_SMBUS_ALERT_ASSERTED)` and RELEASED respectively.

I2C1 Interrupts: `I2C1_EV_IRQHandler` and `I2C1_ER_IRQHandler` are added to forward HAL SMBus handlers. Ensure NVIC priorities are set in CubeMX (Events and Errors enabled). If interrupts are not firing, check startup file vector table contains these symbols.

- Middleware/     — protocols or stacks if you add any.

You can place `BSP/`, `Services/`, `Middleware/` next to `App/`. Update the Makefile to compile them and add `-I` include paths.

## Contract for main.c
- Include `app.h` inside `/* USER CODE BEGIN Includes */`.
- After CubeMX peripheral init, call `app_init()` inside `/* USER CODE BEGIN 2 */`.
- In the main while loop, call `app_step()` inside `/* USER CODE BEGIN WHILE */`.

All real work happens in App and friends.

## Interrupts and callbacks
Keep `stm32f3xx_it.c` as generated. Implement logic in your code and call it from weak callbacks:
- HAL weak callbacks (e.g., `HAL_TIM_PeriodElapsedCallback`) — forward to your module.
- EXTI/IRQ handlers — keep handler signatures in `*_it.c` but immediately call your code in another file.

## HAL handles access
If a module needs a peripheral handle (e.g., `htim4`), either:
- Include `main.h` and declare `extern TIM_HandleTypeDef htim4;`, or
- Create thin BSP wrappers (preferred as project grows), e.g., `bsp_pwm_set(TIM4, CH3, duty)` to avoid leaking HAL details.

## Regeneration notes (CubeMX)
CubeMX may overwrite `Makefile`. If that happens, re-add:
- `App/app.c` to `C_SOURCES`
- `-IApp` to `C_INCLUDES`

Alternatively, keep a small patch script or migrate to a CMake wrapper that includes generated sources plus your folders.

## Current wiring
- `App/app.c` implements a simple PWM ramp on TIM4 CH3.
- `Core/Src/main.c` calls `app_init()` and `app_step()` within USER CODE blocks.

## Build
Use the provided Makefile:

```pwsh
make -C "d:\\Projects\\Private\\Sailing\\semantic-boat\\smart-stack\\smart-switch\\stm32"
```

If CubeMX regenerates code, revisit the Makefile edits described above.
